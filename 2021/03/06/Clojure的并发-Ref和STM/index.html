

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=&#34;auto&#34;>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/favicon.png">
  <link rel="icon" href="/img/favicon.png">
  <meta name="viewport"
        content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  
    <meta name="description" content="">
  
  <meta name="author" content="John Doe">
  <meta name="keywords" content="">
  
  <title>Clojure的并发-Ref和STM - Hexo</title>

  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4.5.3/dist/css/bootstrap.min.css" />


  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/github-markdown-css@4.0.0/github-markdown.min.css" />
  <link  rel="stylesheet" href="/lib/hint/hint.min.css" />

  
    
    
      
      <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@10.4.0/styles/github-gist.min.css" />
    
  

  
    <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.css" />
  



<!-- 主题依赖的图标库，不要自行修改 -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_ba1fz6golrf.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_kmeydafke9r.css">


<link  rel="stylesheet" href="/css/main.css" />

<!-- 自定义样式保持在最底部 -->


  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    var CONFIG = {"hostname":"example.com","root":"/","version":"1.8.8","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"right","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"copy_btn":true,"image_zoom":{"enable":true},"toc":{"enable":true,"headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"onlypost":false},"web_analytics":{"enable":false,"baidu":null,"google":null,"gtag":null,"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":null,"app_key":null,"server_url":null}}};
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
<meta name="generator" content="Hexo 5.4.0"></head>


<body>
  <header style="height: 70vh;">
    <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand"
       href="/">&nbsp;<strong>Fluid</strong>&nbsp;</a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                首页
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                归档
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/">
                <i class="iconfont icon-category-fill"></i>
                分类
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                <i class="iconfont icon-tags-fill"></i>
                标签
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/">
                <i class="iconfont icon-user-fill"></i>
                关于
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" data-toggle="modal" data-target="#modalSearch">&nbsp;<i
                class="iconfont icon-search"></i>&nbsp;</a>
          </li>
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" href="javascript:">&nbsp;<i
                class="iconfont icon-dark" id="color-toggle-icon"></i>&nbsp;</a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

    <div class="banner" id="banner" parallax=true
         style="background: url('/img/default.png') no-repeat center center;
           background-size: cover;">
      <div class="full-bg-img">
        <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
          <div class="page-header text-center fade-in-up">
            <span class="h2" id="subtitle" title="Clojure的并发-Ref和STM">
              
            </span>

            
              <div class="mt-3">
  
  
    <span class="post-meta">
      <i class="iconfont icon-date-fill" aria-hidden="true"></i>
      <time datetime="2021-03-06 18:43" pubdate>
        2021年3月6日 晚上
      </time>
    </span>
  
</div>

<div class="mt-1">
  
    
    <span class="post-meta mr-2">
      <i class="iconfont icon-chart"></i>
      5.3k 字
    </span>
  

  
    
    <span class="post-meta mr-2">
      <i class="iconfont icon-clock-fill"></i>
      
      
      67
       分钟
    </span>
  

  
  
</div>

            
          </div>

          
        </div>
      </div>
    </div>
  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="d-none d-lg-block col-lg-2"></div>
    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div class="py-5" id="board">
          <article class="post-content mx-auto">
            <!-- SEO header -->
            <h1 style="display: none">Clojure的并发-Ref和STM</h1>
            
            <div class="markdown-body">
              <p>clojure处理并发的思路与众不同，采用的是所谓的STM的模型（软事物内存）。你可以将STM想象成数据库，只不过是内存型的，它只支持事物的ACI,也就是原子性，一致性，隔离性，但是不包括持久性，因为状态的保存都在内存里。</p>
<p>C lojure的并发API分为四种模型：</p>
<ul>
<li>管理协作式，同步修改可变状态的Ref</li>
<li>管理非协作式，同步修改可变状态的Atom</li>
<li>管理异步修改可变状态的Agent</li>
<li>管理Thread local变量的Var</li>
</ul>
<h2 id="Ref和STM"><a href="#Ref和STM" class="headerlink" title="Ref和STM"></a>Ref和STM</h2><blockquote>
<p>通过ref函数创建一个可变的引用，指向一个不可变的对象：(ref x)</p>
</blockquote>
<figure class="highlight clojure"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs clojure">(<span class="hljs-keyword">def</span> <span class="hljs-title">song</span> (<span class="hljs-name"><span class="hljs-builtin-name">ref</span></span> #&#123;&#125;))<br></code></pre></td></tr></table></figure>

<blockquote>
<p>deref和@ 取引用的内容，解引用使用deref函数，也可以用reader宏@</p>
</blockquote>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs clojure">user=&gt; (deref song)<br>#&#123;&#125;<br>user=&gt; @song<br>#&#123;&#125;<br></code></pre></td></tr></table></figure>

<blockquote>
<p>ref-set和dosync</p>
</blockquote>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs clojure">改变引用指向的内容，使用ref-set函数:(ref-set ref new-value)<br><br>user=&gt; (ref-set song #&#123;&quot;dangerous&quot;&#125;)<br>Execution error (IllegalStateException) at user/eval1 (REPL:1).<br>No transaction running<br>这是因为引用是可变的，对状态的更新需要进行保护，传统语言的话可能采用锁，Clojure是采用事务，将更新包装到事务里，这是通过dosync实现的：<br>user=&gt; (dosync (ref-set song #&#123;&quot;dangerous&quot;&#125;))<br>#&#123;&quot;dangerous&quot;&#125;<br><br>dosync的参数接受多个表达式，这些表达式将被包装在一个事物里，事物支持ACI<br>（1）Atomic，如果你在事务里更新多个Ref，那么这些更新对事务外部来说是一个独立的操作。<br>（2）Consistent，Ref的更新可以设置 validator，如果某个验证失败，整个事务将回滚。<br>（3）Isolated，运行中的事务无法看到其他事务部分完成的结果。<br>dosync更新多个ref<br>(<span class="hljs-keyword">def</span> <span class="hljs-title">singer</span> (<span class="hljs-name"><span class="hljs-builtin-name">ref</span></span> #&#123;&#125;))<br>(<span class="hljs-name"><span class="hljs-builtin-name">dosync</span></span> (<span class="hljs-name"><span class="hljs-builtin-name">ref-set</span></span> song #&#123;<span class="hljs-string">&quot;Dangerous&quot;</span>&#125;)<br>               (<span class="hljs-name"><span class="hljs-builtin-name">ref-set</span></span> singer #&#123;<span class="hljs-string">&quot;MJ&quot;</span>&#125;) )<br>@song      =&gt;  #&#123;&quot;Dangerous&quot;&#125;<br>@singer    =&gt;  #&#123;&quot;MJ&quot;&#125;<br></code></pre></td></tr></table></figure>

<figure class="highlight clojure"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs clojure">user=&gt; (dosync (ref-set song (conj @song &quot;hah&quot;)))<br>[<span class="hljs-string">&quot;dangerous&quot;</span> <span class="hljs-string">&quot;hah&quot;</span>]<br>user=&gt; (dosync (ref-set song (conj @song &quot;hah&quot;)))<br>[<span class="hljs-string">&quot;dangerous&quot;</span> <span class="hljs-string">&quot;hah&quot;</span> <span class="hljs-string">&quot;hah&quot;</span>]<br>user=&gt; (dosync (ref-set song (conj @song &quot;hah&quot;)))<br>[<span class="hljs-string">&quot;dangerous&quot;</span> <span class="hljs-string">&quot;hah&quot;</span> <span class="hljs-string">&quot;hah&quot;</span> <span class="hljs-string">&quot;hah&quot;</span>]<br>user=&gt; @song<br>[<span class="hljs-string">&quot;dangerous&quot;</span> <span class="hljs-string">&quot;hah&quot;</span> <span class="hljs-string">&quot;hah&quot;</span> <span class="hljs-string">&quot;hah&quot;</span>]<br></code></pre></td></tr></table></figure>

<blockquote>
<p>alter</p>
</blockquote>
<p>完全更新整个引用的值还是比较少见，更常见的更新是根据当前状态更新，例如我们向歌曲集合添加一个歌曲，步骤大概是先查询集合内容，然后往集合里添加歌曲，然后更新整个集合：</p>
<figure class="highlight clojure"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs clojure">(<span class="hljs-name"><span class="hljs-builtin-name">dosync</span></span> (<span class="hljs-name"><span class="hljs-builtin-name">ref-set</span></span> song (<span class="hljs-name"><span class="hljs-builtin-name">conj</span></span> @song <span class="hljs-string">&quot;heal the world&quot;</span>)))<br></code></pre></td></tr></table></figure>

<p>查询并更新的操作可以合成一步，这是通过alter函数：</p>
<figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">(<span class="hljs-keyword">alter</span> <span class="hljs-keyword">ref</span> <span class="hljs-keyword">update</span>-fn &amp; args)<br></code></pre></td></tr></table></figure>

<p>alter接收一个更新的函数，函数将在更新的时候调用，传入当前状态值并返回新的状态值，因此上面的例子可以改写为：</p>
<figure class="highlight clojure"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs clojure">(<span class="hljs-name"><span class="hljs-builtin-name">dosync</span></span> (<span class="hljs-name"><span class="hljs-builtin-name">alter</span></span> song conj <span class="hljs-string">&quot;heal the world&quot;</span>))<br>user=&gt; (dosync (alter song conj &quot;we&quot;))<br>[<span class="hljs-string">&quot;dangerous&quot;</span> <span class="hljs-string">&quot;hah&quot;</span> <span class="hljs-string">&quot;hah&quot;</span> <span class="hljs-string">&quot;hah&quot;</span> <span class="hljs-string">&quot;we&quot;</span>]<br></code></pre></td></tr></table></figure>

<blockquote>
<p><strong>commute</strong></p>
</blockquote>
<p>commute函数是alter的变形，commute顾名思义就是要求update-function是可交换的，它的顺序是可以任意排序。commute的允许的并发程度比alter更高一些，因此性能会更好。但是由于commute要求update-function是可交换的，并且会自动重排序，因此如果你的更新要求顺序性，那么commute是不能接受的,commute仅可用在对顺序性没有要求或者要求很低的场景：例如更新聊天窗口的聊天信息，由于网络延迟的因素和个人介入的因素，聊天信息可以认为是天然排序，因此使用commute还可以接受，更新乱序的可能性很低。<br> 另一个例子就不能使用commute了，如实现一个计数器：</p>
<figure class="highlight clojure"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs clojure">(<span class="hljs-keyword">def</span> <span class="hljs-title">counter</span> (<span class="hljs-name"><span class="hljs-builtin-name">ref</span></span> <span class="hljs-number">0</span>))<br></code></pre></td></tr></table></figure>

<p>实现一个next-counter函数获取计数器的下一个值，我们先使用commute实现：</p>
<figure class="highlight clojure"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs clojure">(<span class="hljs-keyword">defn</span> <span class="hljs-title">next-counter</span> [] (<span class="hljs-name"><span class="hljs-builtin-name">dosync</span></span> (<span class="hljs-name"><span class="hljs-builtin-name">commute</span></span> counter inc)))<br></code></pre></td></tr></table></figure>

<p>这个函数很简单，每次调用inc递增counter的值，接下来写个测试用例：启动50个线程并发去获取next counter:</p>
<figure class="highlight clojure"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs clojure">(<span class="hljs-name"><span class="hljs-builtin-name">dotimes</span></span> [_ <span class="hljs-number">50</span>] (<span class="hljs-name">.start</span> (<span class="hljs-name">Thread.</span> #(<span class="hljs-name">println</span> (<span class="hljs-name">next-counter</span>)))))<br></code></pre></td></tr></table></figure>

<p>这段代码稍微解释下，dotimes是重复执行50次，每次启动new并启动一个Thread,这个Thread里干了两件事情：调用next-counter，打印调用结果,第一个版本的next-counter执行下，这是其中一次输出的截取：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs plain">23<br>23<br>23<br><br>23<br>23<br>23<br>23<br>23<br>23<br>23<br>23<br>23<br>28<br>23<br>21<br>23<br>23<br>23<br>23<br>25<br>28<br></code></pre></td></tr></table></figure>

<p>可以看到有很多的重复数值，这是由于重排序导致事务结束后的值不同，但是你查看counter，确实是50:</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-meta">@counter</span>  =&gt; <span class="hljs-number">50</span><br></code></pre></td></tr></table></figure>

<p>证明更新是没有问题的，问题出在commute的返回值上。</p>
<p>如果将next-counter修改为alter实现：</p>
<figure class="highlight clojure"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs clojure">(<span class="hljs-keyword">defn</span> <span class="hljs-title">next-counter</span> [] (<span class="hljs-name"><span class="hljs-builtin-name">dosync</span></span> (<span class="hljs-name"><span class="hljs-builtin-name">alter</span></span> counter inc)))<br></code></pre></td></tr></table></figure>

<p>此时再执行测试用例，可以发现打印结果完全正确了：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs plain">……<br>39<br>41<br>42<br>45<br>27<br>46<br>47<br>44<br>48<br>43<br>49<br>40<br>50<br></code></pre></td></tr></table></figure>

<p>查看counter，也是正确更新到50了：</p>
<p>@counter =&gt; 50</p>
<p>最佳实践：<strong>通常情况下，你应该优先使用alter</strong>，除非在遇到明显的性能瓶颈并且对顺序不是那么关心的时候，可以考虑用commute替换。</p>
<blockquote>
<p><strong>validator</strong></p>
</blockquote>
<p>类似数据库，你也可以为Ref添加“约束”，在数据更新的时候需要通过validator函数的验证，如果验证不通过，整个事务将回滚。添加validator是通过ref函数传入metadata的map实现的，例如我们要求歌曲集合添加的歌曲名称不能为空：</p>
<p>(def validate-song<br>   (partial every? #(not (nil? %))))</p>
<p>(def song (ref #{} :validator validate-song))</p>
<p>validate-song是一个验证函数，partial返回某个函数的半函数（固定了部分参数，部分参数没固定），你可以将partial理解成currying，虽然还是不同的。validate-song调用every?来验证集合内的所有元素都不是nil，其中#(not (nil? %))是一个匿名函数，%指向匿名函数的第一个参数，也就是集合的每个元素。ref指定了validator为validate-song，那么在每次更新song集合的时候都会将新的状态传入validator函数里验证一下，如果返回false，整个事务将回滚：</p>
<p>(dosync (alter song conj nil))<br>java.lang.IllegalStateException: Invalid reference state (NO_SOURCE_FILE:0)</p>
<p>更新失败，非法的reference状态，查看song果然还是空的：</p>
<p>@song =&gt; #{}</p>
<p>更新正常的值就没有问题：</p>
<p> (dosync (alter song conj “dangerous”))  =&gt; #{“dangerous”}</p>
<blockquote>
<p><strong>ensure</strong></p>
</blockquote>
<p>ensure函数是为了保护Ref不会被其他事务所修改，它的主要目的是为了防止所谓的“<strong>写偏序</strong>”(<strong>write skew</strong>)问题。写偏序问题的产生跟STM的实现有关，clojure的STM实现是基于<a target="_blank" rel="noopener" href="http://en.wikipedia.org/wiki/Multiversion_concurrency_control">MVCC(Multiversion Concurrency Control)</a>——多版本并发控制，对一个Ref保存多个版本的状态值，在更新的时候取得当前状态值的一个隔离的snapshot，更新是基于snapshot进行的。那么我们来看下写偏序是怎么产生，以一个比喻来描述：<br> 想象有一个系统用于管理美国最神秘的军事禁区——51区的安全巡逻，你有3个营的士兵，每个营45个士兵，并且你<strong>需要保证总体巡逻的士兵人数不能少于100个人</strong>。假设有一天，有两个指挥官都登录了这个管理系统，他们都想从某个军营里抽走20个士兵，假设指挥官A想从1号军营抽走，指挥官B想要从2号军营抽走士兵，他们同时执行下列操作：</p>
<p>Admin 1: if ((G1 - 20) + G2 + G3) &gt; 100 then dispatchPatrol</p>
<p>Admin 2: if (G1 + (G2 - 20) + G3) &gt; 100 then dispatchPatrol</p>
<p>我们刚才提到，Clojure的更新是基于隔离的snapshot，一个事务的更改无法看到另一个事务更改了部分的结果，因此这两个操作都因为满足(45-20)+45+45=115的约束而得到执行，导致实际抽调走了40个士兵，只剩下95个士兵，低于设定的安全标准100人，这就是写偏序现象。<br> 写偏序的解决就很简单，在执行抽调前加入ensure即可保护ref不被其他事务所修改。ensure比(ref-set ref @ref)允许的并发程度更高一些。</p>
<h2 id="Atom和缓存"><a href="#Atom和缓存" class="headerlink" title="Atom和缓存"></a>Atom和缓存</h2><p>Ref适用的场景是系统中存在多个相互关联的状态，他们需要一起更新，因此需要通过dosync做事务包装。但是如果你有一个状态变量，不需要跟其他状态变量协作，这时候应该使用Atom了。可以将一个Atom和一个Ref一起在一个事务里更新吗？这没办法做到，如果你需要相互协作，你只能使用Ref。Atom适用的场景是状态是独立，没有依赖，它避免了与其他Ref交互的开销，因此性能会更好，特别是对于读来说。</p>
<h4 id="定义Atom-采用atom函数，赋予一个初始状态"><a href="#定义Atom-采用atom函数，赋予一个初始状态" class="headerlink" title="定义Atom,采用atom函数，赋予一个初始状态"></a>定义Atom,采用atom函数，赋予一个初始状态</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">mem的初始状态定义成一个<span class="hljs-built_in">map</span><br>(<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">mem</span> (<span class="hljs-params">atom &#123;&#125;</span>))</span><br></code></pre></td></tr></table></figure>



<h4 id="deref和-取atom的值"><a href="#deref和-取atom的值" class="headerlink" title="deref和@ 取atom的值"></a>deref和@ 取atom的值</h4><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-meta">@mem</span>         =&gt; &#123;&#125;<br>(deref mem)  =&gt; &#123;&#125;<br></code></pre></td></tr></table></figure>

<h4 id="reset-重新设置atom的值，不关心当前值"><a href="#reset-重新设置atom的值，不关心当前值" class="headerlink" title="reset! 重新设置atom的值，不关心当前值"></a>reset! 重新设置atom的值，不关心当前值</h4><figure class="highlight clojure"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs clojure">(<span class="hljs-name"><span class="hljs-builtin-name">reset!</span></span> mem &#123;<span class="hljs-symbol">:a</span> <span class="hljs-number">1</span>&#125;)<br></code></pre></td></tr></table></figure>

<h4 id="swap-如果你的更新需要依赖当前的状态值，或者只想更新状态的某个部分，那么就需要使用swap-（类似alter"><a href="#swap-如果你的更新需要依赖当前的状态值，或者只想更新状态的某个部分，那么就需要使用swap-（类似alter" class="headerlink" title="swap! 如果你的更新需要依赖当前的状态值，或者只想更新状态的某个部分，那么就需要使用swap!（类似alter)"></a>swap! 如果你的更新需要依赖当前的状态值，或者只想更新状态的某个部分，那么就需要使用swap!（类似alter)</h4><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm">(<span class="hljs-keyword">swap! </span>an-atom f &amp;args)<br><br><span class="hljs-keyword">swap! </span>将函数f作用于当前状态值和额外的参数args之上，形成新的状态值，例如我们给mem加上一个keyword:<br>user=&gt; (<span class="hljs-keyword">swap! </span>mem assoc :<span class="hljs-keyword">b </span><span class="hljs-number">2</span>)<br>&#123;:<span class="hljs-keyword">b </span><span class="hljs-number">2</span>, :a <span class="hljs-number">1</span>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="compare-and-set"><a href="#compare-and-set" class="headerlink" title="compare and set"></a>compare and set</h4><figure class="highlight clojure-repl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs clojure-repl">类似原子变量AtomicInteger之类，atom也可以做compare and set的操作<br>(compare-and-set! atom oldValue newValue)<br><br>当且仅当atom的当前状态值等于oldValue的时候，将状态值更新为newValue，并返回一个布尔值表示成功或者失败:<br><span class="hljs-meta">user=&gt;</span><span class="clojure"> (<span class="hljs-keyword">def</span> <span class="hljs-title">c</span> (<span class="hljs-name"><span class="hljs-builtin-name">atom</span></span> <span class="hljs-number">1</span>))</span><br>#&#x27;user/c<br><span class="hljs-meta">user=&gt;</span><span class="clojure"> (<span class="hljs-name"><span class="hljs-builtin-name">compare-and-set!</span></span> c <span class="hljs-number">2</span> <span class="hljs-number">3</span>)</span><br>false<br><span class="hljs-meta">user=&gt;</span><span class="clojure"> (<span class="hljs-name"><span class="hljs-builtin-name">compare-and-set!</span></span> c <span class="hljs-number">1</span> <span class="hljs-number">3</span>)</span><br>true<br><span class="hljs-meta">user=&gt;</span><span class="clojure"> @c</span><br>3<br></code></pre></td></tr></table></figure>

<h4 id="缓存和atom"><a href="#缓存和atom" class="headerlink" title="缓存和atom"></a>缓存和atom</h4><ul>
<li>atom非常适合实现缓存，缓存通常不会跟其他系统状态形成依赖，并且缓存对读的速度要求更高。上面例子中用到的mem其实就是个简单的缓存例子，我们来实现一个putm和getm函数</li>
</ul>
<figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm"><span class="hljs-comment">;创建缓存</span><br>(defn make-<span class="hljs-keyword">cache </span>[] (atom &#123;&#125;))<br><br><span class="hljs-comment">;;放入缓存</span><br>(defn putm [<span class="hljs-keyword">cache </span>key value] (<span class="hljs-keyword">swap! </span><span class="hljs-keyword">cache </span>assoc key value))<br><br><span class="hljs-comment">;;取出</span><br>(defn getm [<span class="hljs-keyword">cache </span>key] (key @<span class="hljs-keyword">cache))</span><br><span class="hljs-keyword"></span><br><span class="hljs-keyword"></span><br><span class="hljs-keyword"> </span>  这里key要求是keyword，keyword是类似:a这样的字符序列，你熟悉ruby的话，可以暂时理解成symbol。使用这些API：<br>user=&gt; (def <span class="hljs-keyword">cache </span>(make-<span class="hljs-keyword">cache))</span><br><span class="hljs-keyword">#&#x27;user/cache</span><br><span class="hljs-keyword">user=&gt; </span>(putm <span class="hljs-keyword">cache </span>:a <span class="hljs-number">1</span>)<br>&#123;:a <span class="hljs-number">1</span>&#125;<br>user=&gt; (getm <span class="hljs-keyword">cache </span>:a)<br><span class="hljs-number">1</span><br>user=&gt; (putm <span class="hljs-keyword">cache </span>:<span class="hljs-keyword">b </span><span class="hljs-number">2</span>)<br>&#123;:<span class="hljs-keyword">b </span><span class="hljs-number">2</span>, :a <span class="hljs-number">1</span>&#125;<br>user=&gt; (getm <span class="hljs-keyword">cache </span>:<span class="hljs-keyword">b)</span><br><span class="hljs-keyword">2</span><br></code></pre></td></tr></table></figure>

<ul>
<li><strong>memoize</strong>函数作用于函数f，产生一个新函数，新函数内部保存了一个缓存，缓存从参数到结果的映射。第一次调用的时候，发现缓存没有，就会调用f去计算实际的结果，并放入内部的缓存；下次调用同样的参数的时候，就直接从缓存中取，而不用再次调用f，从而达到提升计算效率的目的。<br>memoize的实现就是基于atom，查看源码：</li>
</ul>
<figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs vim">(defn memoize<br>  [<span class="hljs-keyword">f</span>]<br>  (<span class="hljs-keyword">let</span> [mem (atom &#123;&#125;)]<br>    (fn [&amp; <span class="hljs-keyword">args</span>]<br>      (<span class="hljs-keyword">if</span>-<span class="hljs-keyword">let</span> [<span class="hljs-keyword">e</span> (<span class="hljs-keyword">find</span> @mem <span class="hljs-keyword">args</span>)]<br>        (val <span class="hljs-keyword">e</span>)<br>        (<span class="hljs-keyword">let</span> [<span class="hljs-keyword">ret</span> (apply <span class="hljs-keyword">f</span> <span class="hljs-keyword">args</span>)]<br>          (swap! mem assoc <span class="hljs-keyword">args</span> <span class="hljs-keyword">ret</span>)<br>          <span class="hljs-keyword">ret</span>)))))<br><br>内部的缓存名为mem，memoize返回的是一个匿名函数，它接收原有的<span class="hljs-keyword">f</span>函数的参数，<span class="hljs-keyword">if</span>-<span class="hljs-keyword">let</span>判断绑定的变量<span class="hljs-keyword">e</span>是否存在，变量<span class="hljs-keyword">e</span>是通过<span class="hljs-keyword">find</span>从缓存中查询<span class="hljs-keyword">args</span>得到的项，如果存在的话，调用val得到真正的结果并返回；如果不存在，那么使用apply函数将<span class="hljs-keyword">f</span>作用于参数列表之上，计算出结果，并利用swap!将结果加入mem缓存，返回计算结果。<br></code></pre></td></tr></table></figure>

<h4 id="性能测试"><a href="#性能测试" class="headerlink" title="性能测试"></a>性能测试</h4><p>使用atom实现一个计数器，和使用java.util.concurrent.AtomicInteger做计数器，做一个性能比较，各启动100个线程，每个线程执行100万次原子递增，计算各自的耗时，测试程序如下</p>
<figure class="highlight clojure"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs clojure">(<span class="hljs-name"><span class="hljs-builtin-name">ns</span></span> atom-perf)<br>(<span class="hljs-name"><span class="hljs-builtin-name">import</span></span> &#x27;java.util.concurrent.atomic.AtomicInteger)<br>(<span class="hljs-name"><span class="hljs-builtin-name">import</span></span> &#x27;java.util.concurrent.CountDownLatch)<br><br>(<span class="hljs-keyword">def</span> <span class="hljs-title">a</span> (<span class="hljs-name">AtomicInteger.</span> <span class="hljs-number">0</span>))<br>(<span class="hljs-keyword">def</span> <span class="hljs-title">b</span> (<span class="hljs-name"><span class="hljs-builtin-name">atom</span></span> <span class="hljs-number">0</span>))<br><br><span class="hljs-comment">;;为了性能，给java加入type hint</span><br>(<span class="hljs-keyword">defn</span> <span class="hljs-title">java-inc</span> [#<span class="hljs-comment">^AtomicInteger</span> counter] (<span class="hljs-name">.incrementAndGet</span> counter))<br>(<span class="hljs-keyword">defn</span> <span class="hljs-title">countdown-latch</span> [#<span class="hljs-comment">^CountDownLatch</span> latch] (<span class="hljs-name">.countDown</span> latch))<br><br><span class="hljs-comment">;;单线程执行缓存次数</span><br>(<span class="hljs-keyword">def</span> <span class="hljs-title">max_count</span> <span class="hljs-number">1000000</span>)<br><span class="hljs-comment">;;线程数 </span><br>(<span class="hljs-keyword">def</span> <span class="hljs-title">thread_count</span> <span class="hljs-number">100</span>)<br><br>(<span class="hljs-keyword">defn</span> <span class="hljs-title">benchmark</span> [fun]<br>  (<span class="hljs-name"><span class="hljs-builtin-name">let</span></span> [ latch (<span class="hljs-name">CountDownLatch.</span> thread_count)  <span class="hljs-comment">;;关卡锁</span><br>         start (<span class="hljs-name">System/currentTimeMillis</span>) ]     <span class="hljs-comment">;;启动时间</span><br>       (<span class="hljs-name"><span class="hljs-builtin-name">dotimes</span></span> [_ thread_count] (<span class="hljs-name">.start</span> (<span class="hljs-name">Thread.</span> #(<span class="hljs-name"><span class="hljs-builtin-name">do</span></span> (<span class="hljs-name"><span class="hljs-builtin-name">dotimes</span></span> [_ max_count] (<span class="hljs-name">fun</span>)) (<span class="hljs-name">countdown-latch</span> latch))))) <br>       (<span class="hljs-name">.await</span> latch)<br>       (<span class="hljs-name"><span class="hljs-builtin-name">-</span></span> (<span class="hljs-name">System/currentTimeMillis</span>) start)))<br>         <br><br>(<span class="hljs-name">println</span> <span class="hljs-string">&quot;atom:&quot;</span> (<span class="hljs-name">benchmark</span> #(<span class="hljs-name"><span class="hljs-builtin-name">swap!</span></span> b inc)))<br>(<span class="hljs-name">println</span> <span class="hljs-string">&quot;AtomicInteger:&quot;</span> (<span class="hljs-name">benchmark</span> #(<span class="hljs-name">java-inc</span> a)))<br><br>(<span class="hljs-name">println</span> (<span class="hljs-name">.get</span> a))<br>(<span class="hljs-name">println</span> @b)<br></code></pre></td></tr></table></figure>

<p>默认clojure调用java都是通过反射，加入type hint之后编译的字节码就跟java编译器的一致，为了比较公平，定义了java-inc用于调用AtomicInteger.incrementAndGet方法，定义countdown-latch用于调用CountDownLatch.countDown方法，两者都为参数添加了type hint。如果不采用type hint，AtomicInteger反射调用的效率是非常低的。</p>
<p>测试下来，在我的ubuntu上，AtomicInteger还是占优，基本上比atom的实现快上一倍：</p>
<p>atom: 9002<br>AtomicInteger: 4185<br>100000000<br>100000000</p>
<p>按~~照我的理解，这是由于AtomicInteger调用的是native的方法，基于硬件原语做cas，而atom则是用户空间内的clojure自己做的CAS，两者的性能有差距不出意料之外。</p>
<p>~~看了源码，Atom是基于java.util.concurrent.atomic.AtomicReference实现的，调用的方法是</p>
<p> public final boolean compareAndSet(V expect, V update) {<br>    return unsafe.compareAndSwapObject(this, valueOffset, expect, update);<br>  }</p>
<p>而AtomicInteger调用的方法是：</p>
<p>  public final boolean compareAndSet(int expect, int update) {<br>  return unsafe.compareAndSwapInt(this, valueOffset, expect, update);<br>  }</p>
<p>两者的效率差距有这么大吗？暂时存疑。</p>
<h2 id="Agent和Actor"><a href="#Agent和Actor" class="headerlink" title="Agent和Actor"></a>Agent和Actor</h2><p>除了用于协调同步的Ref，独立同步的Ref，还有一类非常常见的需求：你可能希望状态的更新是异步，你通常不关心更新的结果，这时候你可以考虑下使用Agent。</p>
<h4 id="创建agent"><a href="#创建agent" class="headerlink" title="创建agent"></a>创建agent</h4><blockquote>
<p>通过agent函数你就可以创建一个agent，指向一个不可变的初始状态。</p>
</blockquote>
<figure class="highlight clojure-repl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs clojure-repl"><span class="hljs-meta">user=&gt;</span><span class="clojure"> (<span class="hljs-keyword">def</span> <span class="hljs-title">counter</span> (<span class="hljs-name"><span class="hljs-builtin-name">agent</span></span> <span class="hljs-number">0</span>))</span><br>#&#x27;user/counter<br><br><span class="hljs-meta">user=&gt;</span><span class="clojure"> counter</span><br>#&lt;Agent@9444d1: 0&gt;<br></code></pre></td></tr></table></figure>

<h4 id="取agent的值，这跟Ref和Atom没啥两样，都是通过deref或者-宏"><a href="#取agent的值，这跟Ref和Atom没啥两样，都是通过deref或者-宏" class="headerlink" title="取agent的值，这跟Ref和Atom没啥两样，都是通过deref或者@宏"></a><strong>取agent的值</strong>，这跟Ref和Atom没啥两样，都是通过deref或者@宏</h4><figure class="highlight clojure-repl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs clojure-repl"><span class="hljs-meta">user=&gt;</span><span class="clojure"> @counter</span><br>0<br><span class="hljs-meta">user=&gt;</span><span class="clojure"> (<span class="hljs-name"><span class="hljs-builtin-name">deref</span></span> counter)</span><br>0<br></code></pre></td></tr></table></figure>

<h4 id="更新agent，通过send或者send-off函数给agent发送任务去更新agent"><a href="#更新agent，通过send或者send-off函数给agent发送任务去更新agent" class="headerlink" title="更新agent，通过send或者send-off函数给agent发送任务去更新agent"></a><strong>更新agent</strong>，通过send或者send-off函数给agent发送任务去更新agent</h4><figure class="highlight clojure-repl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs clojure-repl"><span class="hljs-meta">user=&gt;</span><span class="clojure"> (<span class="hljs-name"><span class="hljs-builtin-name">send</span></span> counter inc)</span><br>#&lt;Agent@9444d1: 0&gt;<br></code></pre></td></tr></table></figure>

<p>send返回agent对象，内部的值仍然是0，而非inc递增之后的1，这是因为send是异步发送，更新是在另一个线程执行，两个线程(REPL主线程和更新任务的线程)的执行顺序没有同步，显示什么取决于两者谁更快。更新肯定是发生了，查看counter的值：</p>
<p>user=&gt; @counter<br>1</p>
<p>  果然更新到了1了。send的方法签名：</p>
<p>(send a f &amp; args)</p>
<p>  其中f是更新的函数，它的定义如下：</p>
<p>(f state-of-agent &amp; args)</p>
<p>  也就是它会在第一个参数接收当前agent的状态，而args是send附带的参数。</p>
<p>  还有个方法，send-off，它的作用于send类似：</p>
<p>user=&gt; (send-off counter inc)<br>#&lt;Agent@9444d1: 1&gt;<br>user=&gt; @counter<br>2</p>
<p>  send和send-off的区别在于，send是将任务交给一个<strong>固定大小的线程池</strong>执行</p>
<p>final public static ExecutorService pooledExecutor =<br>    Executors.newFixedThreadPool(2 + Runtime.getRuntime().availableProcessors());</p>
<p>  默认线程池大小是<strong>CPU核数加上2</strong>。因此<strong>send执行的任务最好不要有阻塞的操作</strong>。而send-off则使用没有大小限制（取决于内存）的线程池：</p>
<p>final public static ExecutorService soloExecutor = Executors.newCachedThreadPool();</p>
<p>  因此，<strong>send-off比较适合任务有阻塞的操作</strong>，如IO读写之类。请注意，<strong>所有的agent是共用这些线程池</strong>，这从这些线程池的定义看出来，都是静态变量。</p>
<h4 id="异步转同步，刚才提到send和send-off都是异步将任务提交给线程池去处理，如果你希望同步等待结果返回，那么可以使用await函数："><a href="#异步转同步，刚才提到send和send-off都是异步将任务提交给线程池去处理，如果你希望同步等待结果返回，那么可以使用await函数：" class="headerlink" title="异步转同步，刚才提到send和send-off都是异步将任务提交给线程池去处理，如果你希望同步等待结果返回，那么可以使用await函数："></a><strong>异步转同步</strong>，刚才提到send和send-off都是异步将任务提交给线程池去处理，如果你希望同步等待结果返回，那么可以使用await函数：</h4><figure class="highlight clojure"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs clojure">(<span class="hljs-name"><span class="hljs-builtin-name">do</span></span> (<span class="hljs-name"><span class="hljs-builtin-name">send</span></span> counter inc) (<span class="hljs-name"><span class="hljs-builtin-name">await</span></span> counter) (<span class="hljs-name">println</span> @counter))<br></code></pre></td></tr></table></figure>

<p>send一个任务之后，调用await等待agent所有派发的更新任务结束，然后打印agent的值。await是阻塞当前线程，直到至今为止所有任务派发执行完毕才返回。await没有超时，会一直等待直到条件满足，await-for则可以接受等待的超时时间，如果超过指定时间没有返回，则返回nil，否则返回结果。</p>
<p> (do (send counter inc) (await-for 100 counter) (println @counter))</p>
<p>await-for接受的单位是毫秒。</p>
<h4 id="错误处理"><a href="#错误处理" class="headerlink" title="错误处理"></a>错误处理</h4><p>agent也可以跟Ref和Atom一样设置validator，用于约束验证。由于agent的更新是异步的，你不知道更新的时候agent是否发生异常，只有等到你去取值或者更新的时候才能发现：</p>
<p>user=&gt; (def counter (agent 0 :validator number?))<br>#‘user/counter</p>
<p>user=&gt; (send counter (fn[_] “foo”))<br>#&lt;clojure.lang.Agent@4de8ce62: 0&gt;</p>
<p>  强制要求counter的值是数值类型，第二个表达式我们给counter发送了一个更新任务，想将状态更新为字符串”foo”，由于是异步更新，返回的结果可能没有显示异常，当你取值的时候，问题出现了：</p>
<p>user=&gt; @counter<br>java.lang.Exception: Agent has errors (NO_SOURCE_FILE:0)</p>
<p> 告诉你agent处于不正常的状态，如果你想获取详细信息，可以通过agent-errors函数：</p>
<p>user=&gt; (.printStackTrace (agent-errors counter))<br>java.lang.IllegalArgumentException: No matching field found: printStackTrace for class clojure.lang.PersistentList (NO_SOURCE_FILE:0)</p>
<p>  你可以恢复agent到前一个正常的状态，通过clear-agent-errors函数：</p>
<p>user=&gt; (clear-agent-errors counter)<br>nil<br>user=&gt; @counter<br>0</p>
<h4 id="加入事物"><a href="#加入事物" class="headerlink" title="加入事物"></a>加入事物</h4><p>agent跟atom不一样，agent可以加入事务，在事务里调用send发送一个任务，当事务成功的时候该任务将只会被发送一次，最多最少都一次。利用这个特性，我们可以实现在事务操作的时候写文件，达到ACID中的D——持久性的目的:</p>
<p>(def backup-agent (agent “output/messages-backup.clj” ))<br>(def messages (ref []))<br>(use ‘[clojure.contrib.duck-streams :only (spit)])<br>(defn add-message-with-backup [msg]<br>    (dosync<br>      (let [snapshot (commute messages conj msg)]<br>        (send-off backup-agent (fn [filename]<br>                    (spit filename snapshot)<br>                    filename))<br>      snapshot)))</p>
<p>定义了一个backup-agent用于保存消息，add-message-with-backup函数首先将状态保存到messages，这是个普通的Ref，然后调用send-off给backup-agent一个任务：</p>
<p> (fn [filename]<br>     (spit filename snapshot)<br>     filename)</p>
<p>这个任务是一个匿名函数，它利用spit打开文件，写入当前的快照，并且关闭文件，文件名来自backup-agent的状态值。注意到，我们是用send-off，send-off利用cache线程池，哪怕阻塞也没关系。</p>
<p>利用事务加上一个backup-agent可以实现类似数据库的ACID，但是还是不同的，主要区别在于<strong>backup-agent的更新是异步，并不保证一定写入文件</strong>，因此持久性也没办法得到保证。</p>
<h4 id="关闭线程池"><a href="#关闭线程池" class="headerlink" title="关闭线程池"></a>关闭线程池</h4><p>前面提到agent的更新都是交给线程池去处理，在系统关闭的时候你需要关闭这两个线程吃，通过shutdown-agents方法，你再添加任务将被拒绝：</p>
<p>user=&gt; (shutdown-agents)<br>nil<br>user=&gt; (send counter inc)<br>java.util.concurrent.RejectedExecutionException (NO_SOURCE_FILE:0)<br>user=&gt; (def counter (agent 0))<br>#‘user/counter<br>user=&gt; (send counter inc)<br>java.util.concurrent.RejectedExecutionException (NO_SOURCE_FILE:0)</p>
<p>哪怕我重新创建了counter，提交任务仍然被拒绝，进一步证明这些*<strong>*线程池是全局共享**</strong>的。</p>
<h4 id="原理浅析"><a href="#原理浅析" class="headerlink" title="原理浅析"></a>原理浅析</h4><p>前文其实已经将agent的实现原理大体都说了，agent本身只是个普通的java对象，它的内部维持一个状态和一个队列：</p>
<p>  volatile Object state;<br>  AtomicReference<IPersistentStack> q = new AtomicReference(PersistentQueue.EMPTY);</p>
<p>任务提交的时候，是封装成Action对象，添加到此队列</p>
<p>  public Object dispatch(IFn fn, ISeq args, boolean solo) {<br>    if (errors != null) {<br>      throw new RuntimeException(“Agent has errors”, (Exception) RT.first(errors));<br>    }<br>    //封装成action对象<br>    Action action = new Action(this, fn, args, solo);<br>    dispatchAction(action);</p>
<p>​    return this;<br>  }</p>
<p>  static void dispatchAction(Action action) {<br>    LockingTransaction trans = LockingTransaction.getRunning();<br>    // 有事务，加入事务<br>    if (trans != null)<br>      trans.enqueue(action);<br>    else if (nested.get() != null) {<br>      nested.set(nested.get().cons(action));<br>    }<br>    else {<br>      // 入队<br>      action.agent.enqueue(action);<br>    }<br>  }</p>
<p>send和send-off都是调用Agent的dispatch方法，只是两者的参数不一样，dispatch的第二个参数 solo决定了是使用哪个线程池处理action:</p>
<p>(defn send<br> [#^clojure.lang.Agent a f &amp; args]<br>  (. a (dispatch f args false)))</p>
<p>(defn send-off<br> [#^clojure.lang.Agent a f &amp; args]<br>  (. a (dispatch f args true)))</p>
<p>send-off将solo设置为true，当为true的时候使用cache线程池：</p>
<p>  final public static ExecutorService soloExecutor = Executors.newCachedThreadPool();</p>
<p>  final static ThreadLocal<IPersistentVector> nested = new ThreadLocal<IPersistentVector>();</p>
<p>​    void execute() {<br>​      if (solo)<br>​        soloExecutor.execute(this);<br>​      else<br>​        pooledExecutor.execute(this);<br>​    }</p>
<p>执行的时候调用更新函数并设置新的状态：</p>
<p>try {<br>          Object oldval = action.agent.state;<br>          Object newval = action.fn.applyTo(RT.cons(action.agent.state, action.args));<br>          action.agent.setState(newval);<br>          action.agent.notifyWatches(oldval, newval);<br>        }<br>        catch (Throwable e) {<br>          // todo report/callback<br>          action.agent.errors = RT.cons(e, action.agent.errors);<br>          hadError = true;<br>        }</p>
<h4 id="跟actor的比较"><a href="#跟actor的比较" class="headerlink" title="跟actor的比较"></a>跟actor的比较</h4><p>Agent跟Actor有一个显著的不同，agent的action来自于别人发送的任务附带的更新函数，而actor的action则是自身逻辑的一部分。因此，如果想用agent实现actor模型还是相当困难的，下面是我的一个尝试：</p>
<p>(ns actor)</p>
<p>(defn receive [&amp; args]<br>  (apply hash-map args))<br>(defn self [] <em>agent</em>)</p>
<p>(defn spawn [recv-map]<br>  (agent recv-map))</p>
<p>(defn ! [actor msg]<br>  (send actor #(apply (get %1 %2) (vector %2)) msg))<br>;;启动一个actor<br>(def actor (spawn<br>       (receive :hello #(println “receive “%))))<br>;;发送消息 hello<br>(! actor :hello)</p>
<p>  利用spawn启动一个actor，其实本质上是一个agent，而发送通过感叹号!，给agent发送一个更新任务，它从recv-map中查找消息对应的处理函数并将消息作为参数来执行。难点在于消息匹配，匹配这种简单类型的消息没有问题，但是如果匹配用到变量，暂时没有想到好的思路实现，例如实现两个actor的ping/pong。</p>
<p><a target="_blank" rel="noopener" href="http://www.blogjava.net/killme2008/archive/2010/07/archive/2010/07/archive/2010/07/archive/2010/07/14/326027.html">http://www.blogjava.net/killme2008/archive/2010/07/archive/2010/07/archive/2010/07/archive/2010/07/14/326027.html</a></p>

            </div>
            <hr>
            <div>
              <div class="post-metas mb-3">
                
                
              </div>
              
                <p class="note note-warning">
                  
                    本博客所有文章除特别声明外，均采用 <a target="_blank" href="https://creativecommons.org/licenses/by-sa/4.0/deed.zh" rel="nofollow noopener noopener">CC BY-SA 4.0 协议</a> ，转载请注明出处！
                  
                </p>
              
              
                <div class="post-prevnext">
                  <article class="post-prev col-6">
                    
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2021/03/06/Clojure%E7%9A%84%E5%B9%B6%E5%8F%91-Agent%E6%B7%B1%E5%85%A5%E5%88%86%E6%9E%90%E5%92%8CActor/">
                        <span class="hidden-mobile">Clojure的并发-Agent深入分析和Actor</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
          </article>
        </div>
      </div>
    </div>
    
      <div class="d-none d-lg-block col-lg-2 toc-container" id="toc-ctn">
        <div id="toc">
  <p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;目录</p>
  <div class="toc-body" id="toc-body"></div>
</div>

      </div>
    
  </div>
</div>

<!-- Custom -->


    

    
      <a id="scroll-top-button" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v"
                 for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>
    

    
  </main>

  <footer class="text-center mt-5 py-3">
  <div class="footer-content">
     <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
  </div>
  

  

  
</footer>

<!-- SCRIPTS -->

  <script  src="https://cdn.jsdelivr.net/npm/nprogress@0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/nprogress@0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://cdn.jsdelivr.net/npm/jquery@3.5.1/dist/jquery.min.js" ></script>
<script  src="https://cdn.jsdelivr.net/npm/bootstrap@4.5.3/dist/js/bootstrap.min.js" ></script>
<script  src="/js/debouncer.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>

<!-- Plugins -->


  
    <script  src="/js/lazyload.js" ></script>
  



  



  <script  src="https://cdn.jsdelivr.net/npm/tocbot@4.12.0/dist/tocbot.min.js" ></script>



  <script  src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.js" ></script>



  <script  src="https://cdn.jsdelivr.net/npm/anchor-js@4.3.0/anchor.min.js" ></script>



  <script defer src="https://cdn.jsdelivr.net/npm/clipboard@2.0.6/dist/clipboard.min.js" ></script>






  <script  src="https://cdn.jsdelivr.net/npm/typed.js@2.0.11/lib/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var title = document.getElementById('subtitle').title;
      
      typing(title)
      
    })(window, document);
  </script>



  <script  src="/js/local-search.js" ></script>
  <script>
    (function () {
      var path = "/local-search.xml";
      $('#local-search-input').on('click', function() {
        searchFunc(path, 'local-search-input', 'local-search-result');
      });
      $('#modalSearch').on('shown.bs.modal', function() {
        $('#local-search-input').focus();
      });
    })()
  </script>















<!-- 主题的启动项 保持在最底部 -->
<script  src="/js/boot.js" ></script>



</body>
</html>
